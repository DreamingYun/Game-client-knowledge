内联函数是在 C++ 中增加的一个功能，可以提高程序执行效率。如果函数是内联的，编译器在编译时，会把内联函数的实现替换到每个调用内联函数的地方，可以与宏函数作类比，但宏函数不会进行类型检查。

可以将普通函数或者类的成员函数声明为内联。

内联函数一般要求如下：

\1. 函数简短，通常3-5行；

\2. 函数内没有复杂的实现，比如：包含while、for 循环，递归等；

\3. 通常在多处有调用；

注意：函数声明为内联，仅仅是对编译器的建议，如果函数比较复杂，编译器会将其看做普通函数。

来看一个简单的例子，如下所示：

内联函数是在编译时将函数的代码插入到调用该函数的地方，以减少函数调用的开销和提高程序性能。以下是几种内联函数定义的方式：



\1. 在函数定义处使用 inline 关键字：

  

   inline int Add(int x, int y) {

​       return x + y;

   }

   这种方式是最常见的内联函数定义方式，将函数定义与声明合并在一起，并使用 `inline` 关键字告诉编译器将该函数内联展开。



\2. 使用宏定义实现内联函数：



   \#define Add(x, y) ((x) + (y))

   使用宏定义可以实现简单的内联函数效果，但宏定义不会进行类型检查，可能会导致意外的错误或副作用，应谨慎使用。



\3. 使用模板函数实现内联函数：



   template<typename T>

   inline T Add(T x, T y) {

​       return x + y;

   }

   使用模板函数可以实现通用的内联函数定义，对于不同类型的参数都可以进行内联展开，提高代码的灵活性和复用性。



这些都是常见的内联函数定义方式，选择合适的方式取决于具体的场景和需求，一般来说，推荐使用第一种方式，即在函数定义处使用 `inline` 关键字。





为什么要使用内联函数 （优点）

引入内联函数主要是解决一些频繁调用的小函数消耗大量空间的问题。

通常情况下，在调用函数时，程序会将控制权从调用程序处转移到被调用函数处，在这个过程中，传递参数、寄存器操作、返回值等会消耗额外的时间和内存，如果调用的函数代码量很少，也许转移到调用函数的时间比函数执行的时间更长。而如果使用内联函数，内联函数会在调用处将代码展开，从而节省了调用函数的开销。



内联函数的缺点：

内联函数是一种在编译时将函数代码插入到调用处的优化手段，可以提高程序的执行效率，但也存在一些缺点：



\1. 代码膨胀：内联函数会将函数代码插入到每个调用处，可能导致代码量的增加，特别是对于复杂的函数。这会增加可执行程序的体积，并可能降低指令缓存的效率，从而影响性能。



\2. 编译时间增加：由于内联函数会在每个调用处插入代码，编译器需要处理更多的代码，导致编译时间增加。特别是在包含大量内联函数的大型项目中，编译时间可能会显著增加。



\3. 无法递归内联：由于内联函数在编译时展开，如果函数内部存在递归调用，编译器无法展开递归内联，这可能限制了内联函数的使用范围。



\4. 可读性降低：内联函数的定义通常放在头文件中，这样会导致头文件中包含大量的函数实现代码，降低了代码的可读性和维护性。



\5. 编译器限制：编译器可能会限制内联函数的大小和复杂度，过大或过复杂的函数可能不会被内联。



因此，在使用内联函数时，需要权衡利弊并根据实际情况进行选择。通常适合内联的函数是短小且频繁调用的函数，对于复杂函数或调用不频繁的函数，可以考虑不使用内联。另外，现代编译器会根据情况自动进行内联优化，因此不需要过度依赖手动内联函数来优化性能。