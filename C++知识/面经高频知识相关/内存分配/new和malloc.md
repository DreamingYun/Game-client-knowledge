# new和malloc失败情况

1.c++ 标准 **new** 失败是抛出异常的，使用new(std::nothrow)可以保证失败时返回NULL;

因此完全可以 #define new new(std::nothrow) .

2.使用 **malloc/calloc** 等分配内存的函数时，一定要检查其返回值是否为“空指针”,返回空指针表示申请内存失败。

\#define new new(std::nothrow)char *p = new char[4];

if(p != NULL)

{

​      strcpy(p, "hi");  

}

3.申请内存失败的原因:程序**用完**了所有的可用内存.





# **new 和malloc有什么区别**

`new` 和 `malloc` 都是用于动态分配内存的方法，但是它们之间有一些重要的区别：



### 1.类型安全性：

​    `new` 是 C++ 中的操作符，它会调用构造函数来初始化对象，并返回该对象的指针。因此，`new` 是类型安全的，可以**确保分配的内存和对象类型匹配**。

​    `malloc` 是 C 语言中的函数，它只分配内存空间，并不会调用构造函数初始化对象。因此，使用 `malloc` 分配内存时需要手动管理对象的构造和析构，不具备类型安全性。



### 2.返回类型：

​    `new` 返回的是对象类型的指针，而且不需要进行类型转换。

​    `malloc` 返回的是 `void*` 类型的指针，需要显式进行类型转换。



### 3.内存大小：

   `new` 在分配对象时会考虑对象的大小和对齐要求，因此可以确保分配的内存足够存储对象。

​    `malloc` 只分配指定大小的内存块，需要开发者自行计算对象的大小和对齐要求，并进行相应的内存分配。



### 4.对于数组的处理：

   `new` 和 `delete` 可以直接用于动态数组的分配和释放，并且会**自动调用数组元素**的构造函数和析构函数。

​    `malloc` 和 `free` 可以用于动态数组的分配和释放，但是需要开发者**手动调用**每个数组元素的构造函数和析构函数