## 一、了解哈希表及哈希冲突



哈希表：是一种实现关联数组抽象数据类型的数据结构（**“关联数组”是一种具有特殊索引方式的数组。**不仅可以通过整数来索引它，还可以使用字符串或者其他类型的值（除了NULL）来索引它），这种结构可以将关键码映射到给定值。简单来说哈希表（key-value）之间存在一个映射关系，是键值对的关系，一个键对应一个值。



哈希冲突：当两个不同的数经过哈希函数计算后得到了同一个结果，即他们会被映射到哈希表的同一个位置时，即称为发生了哈希冲突。简单来说就是哈希函数算出来的地址被别的元素占用了。



## 二、解决哈希冲突办法



1、开放定址法：我们在遇到哈希冲突时，去寻找一个新的空闲的哈希地址



（1）线性探测法



​        当我们的所需要存放值的位置被占了，我们就往后面一直加1并对m取模直到存在一个空余的地址供我们存放值，取模是为了保证找到的位置在0~m-1的有效空间之中。



（2）平方探测法（二次探测）



当我们的所需要存放值的位置被占了，会前后寻找而不是单独方向的寻找。



​        公式：h(x)=(Hash(x) +i)mod (Hashtable.length);（i依次为+(i^2)和-(i^2)）



2、再哈希法：同时构造多个不同的哈希函数，等发生哈希冲突时就使用第二个、第三个……等其他的哈希函数计算地址，直到不发生冲突为止。虽然不易发生聚集，但是增加了计算时间



3、链地址法：将所有哈希地址相同的记录都链接在同一链表中



4、建立公共溢出区：将哈希表分为基本表和溢出表，将发生冲突的都存放在溢出表中



## 三、unordered_map

unordered_map构造函数

unordered_map比较重要的构造函数如下：

默认构造函数

std::unordered_map<Key, T> myMap;

1

创建一个空的unordered_map对象，键的类型为Key，值的类型为T。

初始桶数构造函数

std::unordered_map<Key, T> myMap(size_t n);

1

创建一个空的unordered_map对象，键的类型为Key，值的类型为T。这个构造函数会将unordered_map初始的桶数设置为n。（桶是哈希表中用于存储数据的位置与容器）





## unordered_map性能分析

std::unordered_map是一个哈希表实现的关联容器，它具有以下优点：

O(1)的平均查找时间：由于哈希表使用哈希函数将键映射到桶中，查找元素的时间复杂度为O(1)，即平均需要常量时间查找元素。

高效的元素添加和删除：由于哈希表内部使用链表或红黑树来解决哈希冲突，因此在添加和删除元素时，只需要在对应桶的链表或红黑树中进行常量时间的操作。

适用于大规模数据：由于哈希表的查找时间复杂度为O(1)，因此它在处理大规模数据时表现良好，尤其是当键的范围很大时，比如对于字符串作为键的情况。

自定义键类型：哈希表可以处理自定义类型的键，只需要为该类型提供哈希函数和相等比较函数即可。

但是，std::unordered_map也存在以下一些缺点：

哈希表需要预先指定桶的数量和负载因子，当桶的数量或负载因子不合理时，会影响哈希表的性能。(太少增多，太多耗内存）

哈希表的内存使用效率不高，因为哈希表需要维护桶数组和每个桶内的链表或红黑树，这会增加内存开销。

当哈希冲突较多时，哈希表的性能会下降，因为查找元素需要遍历桶内的链表或红黑树。

哈希表的迭代器不稳定，当哈希表的元素被添加或删除时，迭代器可能会失效。

总体来说，std::unordered_map是一个高效的关联容器，适用于大规模数据的处理，但是需要合理设置桶的数量和负载因子，并注意处理哈希冲突和迭代器失效的问题。





## 哈希表应用场景

快速查找、唯一性检查