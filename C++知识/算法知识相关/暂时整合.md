1.用数组代替vector运行，可以减少时间复杂度，毕竟其查找速度更快，不过需要预留好其对应的内存

···

bool dp[m][aimMax+1];//索引范围下，是否可以达到目标值

​    memset(dp,false,sizeof(bool)*m*(aimMax+1));

···

2.unordered_set为唯一对象的集合，不管有多少元素，存储进去永远不会重复（.count()永远为1，如果元素存在的话），所以可以用于不重复的交集问题

3.关系如下

```
旋转后的关系是 [0][0] - [0][2]  [0][1] - [1][2]  [1][0] - [0][1]   aim[i][j] - aim[j][n-i-1]
水平轴旋转 aim[i][j] - aim[n-i-1][j]   对角线翻转 aim[n-i-1][j] - aim[j][n-i-1]
```

旋转图像通过水平加对角实现原地旋转

4.tuple作为vector的元素时，插入时按顺序填入即可

```c++
vector<tuple<int,int,int>> aimTwo;

        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                aimTwo.emplace_back(nums1[i]+nums2[j],nums1[i],nums2[j]);
            }
        }
```

tuple获取元素的方式，获取第一个元素

```c++
get<0>(aimVec[right])
```



5.二维数组vector插入元素的方式

```c++
 ans.push_back({get<1>(aimVec[i]),get<2>(aimVec[i])});
```



6.string字符串操作，**字符串substr（size_t pos，size_t len）const;** 输入起始位置和裁剪长度

```c++
s.substr(0,s.size())
```



7.unordered_map不含有元素会不会设置默认值

`unordered_map` 是 C++ STL 库中的一个无序关联容器，它存储键值对，并提供快速的查找、添加和删除操作。当你尝试访问 `unordered_map` 中不存在的元素时，你会得到一个默认构造的值，而不是一个设定的默认值。

举个例子，如果你有一个 `unordered_map<int, int>`，当你尝试访问一个不存在的键对应的值时，你会得到一个默认构造的 `int`（也就是 `0`），而不是设置的默认值。

如果你想要在访问不存在的元素时设置一个默认值，你需要自己编写逻辑来实现。例如，你可以先检查元素是否存在，如果不存在，则插入一个带有默认值的新元素。



8.深度搜索和广度搜索的区别

深度搜索和广度搜索的主要区别在于它们探索问题空间的策略不同，具体区别如下：

- 探索方式不同。深度搜索是一种递归的搜索算法，它沿着一条路径尽可能深入地搜索，直到达到目标或路径尽头，然后**回溯**并探索下一条路径；广度搜索则是一种层次化的搜索，它从根节点开始，先探索所有子节点，然后再探索**那些子节点的孙子节点**，以此类推。
- 适用场景不同。深度搜索适合于目标路径较短且深入的情况，比如二叉树的遍历；广度搜索则适合于需要搜索整个空间或寻找最短路径的情况，如迷宫求解和图遍历。
- 资源消耗不同。深度搜索通常需要较少的内存空间，因为它只需存储当前路径的信息，但在某些情况下可能运行速度较慢；广度搜索需要更多的内存空间来存储所有开放的节点，但它通常运行得更快，因为它可以并行探索多个路径。
- 目标确定性不同。深度搜索可能找不到最短路径，甚至可能陷入无限循环；广度搜索则能保证找到到目标状态的最短路径。





9.对queue队列而言push为插入尾部，front为首部，back为尾部，pop()就是弹出第一个元素（当前，也就是首部第一个)



10.`static constexper int` 和 `int` 的区别在于前者是一个编译时常量表达式，而后者只是一个普通的整数变量。`static constexper int` 在编译时就会被求值，而且具有**静态存储期**和**常量表达式属性**，因此在运行时具有更高的效率和安全性。相比之下，普通的 `int` 变量在运行时才被赋值，并且可以被修改。



11.INT_MIN = -2的31次方

12.INT_MAX = 2的31次方-1

13.除法可以转换为减法，效果相同



14.提高速度的方法 - 提前设置好大小，然后直接赋值即可     与运算的妙用，来模拟得到该数2进制后含有1的个数

15.在判断字母串是否相同的时候，可以通过位掩码的方式，记录每个字母的存在与否（1、0）

for(int i=0;i<count;i++){

​      string curWord = words[i];

​      for(int j=0;j<curWord.size();j++){

​        mask[i] |= 1<<(curWord[j]-'a');//位掩码,|为了1和1还是1

​      }

​    }

接着使用与运算进行比较

if((mask[i] & mask[j]) == 0)





16.在想要查找两个数的时候，可以使用for加上二分查找的方式，比for嵌套更加提高效率

17.在想要查找三个数的时候，可以用for加上双指针的方式

18.在计算连续数组相关问题时，使用滑动窗口更便于理解 start 、end，但是数组内不能出现负数

19.针对负数出现的连续数组情况，可以使用前缀和+哈希表的方法---转变思路为前缀和减去前面的前缀和，从而获得到连续的相减下来的数组和
pre - (pre-k) = k



20.寻找异位词的题目，可以使用双指针left、right形成通解



21.在寻找最长连续子串，一般以左指针为主要移动单位（以左指针为移动单位，防止末尾出现讨论相同还是最后的情况）

22.在while循环的条件块，尽量不要用s.size()，而且提前计算好，用n进行循环，防止bug



23.寻找s中包含t的最短字符串，思路就是用两个unordered_map分别存储t的字符数量和当前左右指针下的区间中字符数量，先动右指针，再缩左指针，始终只考虑t的字符，其他的不考虑。最终使用s.substr返回固定位置长度的字符串即可



24.寻找多个回文串的时候，可以使用中心拓展法（中心为奇数偶数）

25.链表删除结点问题，需要考虑删除头节点的情况，preNode可以改变head后的情况，但是如果该head被删除，那么应该以preNode的next作为新的头节点



26.ListNode*存储的就是指针，而指针是独一无二的

27.倒序用栈处理

28.vector<ListNode*> vec 其下标就是数字，对应值为ListNode

29.不论是循环链表还是双向链表，最基础就是要保持结构，也就是每个存在的节点的每个字段都要有值

30.随机数 ： rand()%nums.size()  搭配srand((unsigned)time(NULL));

31.vector也可以pop_back() 和 back()进行末尾数据的管理

32.使用vector的size()和unorded_map的size()区别就在于unordered_map会出现哈希冲突，就会将时间复杂度从o(1)变为o(n)



33.在做LRU缓存这类问题（涉及到最少使用）可以用双向链表来更新头结点，达到相同的效果

34.字母异位词（字母出现次数相同，顺序不同）可以用排序的方法来实现快速判断是否为异位词

35.如果要保存每个单词或者字符的大小，可以直接使用Vector<int>来代替unordered_map<char,int>，首先不用char，其次vector本身每个元素就对应有值，这样速度更快

36.冒泡排序(不断缩小的比较范围)不如sort更快，所以仍需要其他的算法（面试时）

37.*c++中switch是不支持string*,float等的,只支持整形类(int,char等)

38.当题目要求返回vector，但是题意需要使用些栈的思维，就可以使用vector的back()和pop_back()来实现栈模拟（小行星）

39.单调栈更像一个顺序图标题，如下

stack<int> stk;//不断向后存，直到遇到大的再往前弹出，直到没有比大的更小的

这样就可以精确知道每个坐标下的值和与该值最接近但更高的值其坐标之间的距离

40.stack<int> stk;//单调栈，存的都是递增的数据，因为不递增的不会存入

则求柱状图中的最大矩形的思路就是以当前高度向左右拓展，就是当前最大矩形了！



41.队列queue的弹出pop就是弹出头部元素（front()），而push就是插入尾部元素，top()就是队首的值

42.队列因为其先进先出的特性，可以用于广度搜索（每层可以用当时的size进行while循环达到效果）

43.在二叉树中，要删除节点，还是要对->left->right进行操作，才会生效

44.在求二叉树路径的时候，可以使用容器存储前缀和，dfs先存储后清除（向深递归，再向浅回溯）

45.在二叉树中，切记递归是先到叶子节点，然后一步步往上回到根节点，利用这一特性可以获取到最优的叶子节点的选择（使用max达到可选可不选的地步）

46.先递归到叶子节点的原因是，递归的函数都没有结束，直到递归到空节点return，才开始了回溯，此时回溯的就是叶子节点

47.二叉树包括链表，想要连起来，每次向下拓展的节点，都应该和之前的节点有联系

​    resNode->right = root;

​    resNode = root;//向下更新

48.中序遍历，也是从叶子节点处，向上到根节点，然后再到根节点的右边的节点向下

49.二叉搜索树的特性使得遍历的顺序结合后会造成不同树（累加树）的形成

50.在寻找特定数据的时候，不一定要存完再找，可以是边存储边寻找（k-root->val）

51.set虽然是自动升序排序，但是其lower_bound方法（找到第一个大于等于目标值的元素）可以使用auto it=saveSet.begin()这样的for循环代替，值得注意的是，如果没有找到会返回saveSet.end()，这个时候--saveSet.end()就是末尾的元素

52.priority_queue默认为最大优先队列（top返回的是最大值），如果想要最小优先的话，需要初始化为priority_queue<int,vector<int>,greater<int>> 

53.priority使用emplace可以存入更多类型的元素，因为其缺少begin，所以遍历需要使用while（）与pop()结合的方式

54.构造自定义比较方式的优先队列

priority_queue<pair<int,int>,vector<int,int>,decltype(&cmp)> p(cmp);

55.vector默认是按照升序，priority_queue默认是按照降序，所以在cmp的使用上，是相反的。vector如果要升序就返回true，第一个参数在第二个参数之前 ，priority如果要降序就返回true，第一个参数在第二个参数之后

56.队列问题，top和pop一定要对上

57.在cmp中，需要出现静态成员，但是静态成员需要在类外链接起来

class Solution {

private:

  static vector<int> numsFirst;

  static vector<int> numsSecond;  

  static bool cmp(const pair<int,int>& a,const pair<int,int>& b){

​    return numsFirst[a.first]+numsSecond[a.second] > numsFirst[b.first] + numsSecond[b.second];//升序排序

  }   };

//类外链接

vector<int> Solution::numsFirst;

vector<int> Solution::numsSecond; 

58.构造函数

Trie() : vec(26) {

​    isEnd = false;

  }

通过resize一样可以实现Trie(){

​    vec.resize(26,nullptr);

​    isEnd = false;

  }



59.前缀树的本质是将字符串中每个字母变为树的一个叶子，每个单词就是一个子树。步骤也是通过建立一个类，设置一些方法，一般涉及保存和读取。包括容器（26大小），是否结束（isEnd)

60.字符串扩充字符，使用+=

字符串扩充字符串，使用append

字符串选择字符串，使用s.substr(开始索引,长度)、s.substr(开始索引)-默认到最长长度为止

61.在一定条件下，使用哈希存储比前缀树更为简单

62.当然前缀树叶不一定只带着isEnd，也可以带着count来随着存储计数当前到该字母时的前缀数量

63.二分查找关键在于，一开始的result要设置为size()，因为可能大于所有的元素，而且不需要找到就退出，而是while循环尽量靠近，所以其实只要两个判断条件即可。left<=right 尽可能多一个解。至于等于的代码放在哪里，需要看题目是要求尽可能大些还是尽可能小些。以上是不变的公式

64.求二进制数异或最大，其实就是让每一位尽可能为1，则可以采用前缀树，不同的是，这里仅仅保存left(0)和right(1)作为一种二叉树，思路就是存储之后，在遍历的时候，寻找尽可能凑到1的树。边存储边比较大小，是因为在后续存储的数据越多的时候，就更加精确。并且在保证了至少有0或1的树的情况下（31位铺满），一定会有结果

65.

- 当 *mid* 是偶数时，*mid*+1=*mid*⊕1；//右边
- 当 *mid* 是奇数时，*mid*−1=*mid*⊕1。//左边

66.二分查找可以作为快速寻找某值的方式，不断缩小查找范围，直到找到目标值为止

67.排序最终还是可以回归到cmp与sort结合

68.在进行static变量的设置时候，记得在一开始调用clear来清除之前的数据，比如unordered_map这种类型

69.快速排序的思路就是使用随机数，获得当前区间的一个下标，然后将其放到末尾，对这段不包括末尾的区间进行分类，小于该下标值的放左边，大于在右，然后分类完后，将此下标放在分类的中间，如果下标是目标值就返回，否则则分别在左区间，右区间寻找，不断递归

70.时间复杂度是 O(nlogn) 的排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是 O(n 2)），其中最适合链表的排序算法是归并排序。

71.归并排序（自顶向下），最适合于链表排序（其他颜色是递归，蓝色是回溯）

![](%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.png)

72.在求子集类似问题时，可以使用递归回溯，即对包括当前元素与否进行讨论，并且在先存入递归再弹出递归，可以使得回溯上来是刚开始的状态

73.递归的末尾void方法，其实包括return

74.在排序好的vector<int>中去存储每个值出现次数，可以使用vector<pair<int,int>> saveVec容器，这和unordered_map<int,int>的区别在于可以正常使用下标读取每个元素，而不用启用遍历，一步到位

75.在重排序这方面，不仅可以枚举，也可以交换元素来实现

76.重复元素只在它们的从左到右第一个出现位置被使用，从而防止生成重复的排列。

i>0 && nums[i]==nums[i-1] && !saveVec[i-1]

77.string等同于vector<char>，只不过string只能用push_back（char），string的每个元素就是char''

78.动态规划可以判断回文串，从后往前不断拓展

```
//区间内为回文串
        vector<vector<bool>> isHui(n,vector<bool>(n,true));//单字符是回文，确保[i+1][j-1]不影响正确结果

        //动态规划判断是否为回文串
        for(int i=n-1;i>=0;i--){
            for(int j=i+1;j<n;j++){
                isHui[i][j] = (s[i]==s[j]) && isHui[i+1][j-1];//如果内圈本身是回文串且两者相同，则为回文串
            }
        }
```

79.使用emplace_back与pop_back出现超出时间限制的时候，可以使用resize，即只进行赋值，也能达到相同的效果，还不会超时

80.走楼梯，从0层开始到楼层不用花费体力，花费体力只在于从之后的楼层上来需要花费当前楼层体力和之前的体力，最后返回仍然是dp[n]因为，代表了到顶部可以是踩着n-1上来的，只要超过n-1层就是顶部，是楼层顶部的定义

81.在解决斐波那契序列的问题上，dp数组的含义通常指以下标i和下标j为斐波那契数列的末尾两元素的时候，其最长的长度（寻找到目标元素，然后以目标元素和下标i为基准跟上+1）

82.在解决最长公共子序列的问题上，可以通过判断上下字符串的选择来尽可能贴近获得当前下标的最长字符串

if(c1 == c2){

 dp[i][j] = dp[i-1][j-1]+1;

  }else{

  dp[i][j] = max(dp[i][j-1],dp[i-1][j]);//上下选择

  }

