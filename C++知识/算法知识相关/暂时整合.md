1.用数组代替vector运行，可以减少时间复杂度，毕竟其查找速度更快，不过需要预留好其对应的内存

···

bool dp[m][aimMax+1];//索引范围下，是否可以达到目标值

​    memset(dp,false,sizeof(bool)*m*(aimMax+1));

···

2.unordered_set为唯一对象的集合，不管有多少元素，存储进去永远不会重复（.count()永远为1，如果元素存在的话），所以可以用于不重复的交集问题

3.关系如下

```
旋转后的关系是 [0][0] - [0][2]  [0][1] - [1][2]  [1][0] - [0][1]   aim[i][j] - aim[j][n-i-1]
水平轴旋转 aim[i][j] - aim[n-i-1][j]   对角线翻转 aim[n-i-1][j] - aim[j][n-i-1]
```

旋转图像通过水平加对角实现原地旋转

4.tuple作为vector的元素时，插入时按顺序填入即可

```c++
vector<tuple<int,int,int>> aimTwo;

        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                aimTwo.emplace_back(nums1[i]+nums2[j],nums1[i],nums2[j]);
            }
        }
```

tuple获取元素的方式，获取第一个元素

```c++
get<0>(aimVec[right])
```



5.二维数组vector插入元素的方式

```c++
 ans.push_back({get<1>(aimVec[i]),get<2>(aimVec[i])});
```



6.string字符串操作，**字符串substr（size_t pos，size_t len）const;** 输入起始位置和裁剪长度

```c++
s.substr(0,s.size())
```



7.unordered_map不含有元素会不会设置默认值

`unordered_map` 是 C++ STL 库中的一个无序关联容器，它存储键值对，并提供快速的查找、添加和删除操作。当你尝试访问 `unordered_map` 中不存在的元素时，你会得到一个默认构造的值，而不是一个设定的默认值。

举个例子，如果你有一个 `unordered_map<int, int>`，当你尝试访问一个不存在的键对应的值时，你会得到一个默认构造的 `int`（也就是 `0`），而不是设置的默认值。

如果你想要在访问不存在的元素时设置一个默认值，你需要自己编写逻辑来实现。例如，你可以先检查元素是否存在，如果不存在，则插入一个带有默认值的新元素。



8.深度搜索和广度搜索的区别

深度搜索和广度搜索的主要区别在于它们探索问题空间的策略不同，具体区别如下：

- 探索方式不同。深度搜索是一种递归的搜索算法，它沿着一条路径尽可能深入地搜索，直到达到目标或路径尽头，然后**回溯**并探索下一条路径；广度搜索则是一种层次化的搜索，它从根节点开始，先探索所有子节点，然后再探索**那些子节点的孙子节点**，以此类推。
- 适用场景不同。深度搜索适合于目标路径较短且深入的情况，比如二叉树的遍历；广度搜索则适合于需要搜索整个空间或寻找最短路径的情况，如迷宫求解和图遍历。
- 资源消耗不同。深度搜索通常需要较少的内存空间，因为它只需存储当前路径的信息，但在某些情况下可能运行速度较慢；广度搜索需要更多的内存空间来存储所有开放的节点，但它通常运行得更快，因为它可以并行探索多个路径。
- 目标确定性不同。深度搜索可能找不到最短路径，甚至可能陷入无限循环；广度搜索则能保证找到到目标状态的最短路径。





9.对queue队列而言push为插入尾部，front为首部，back为尾部，pop()就是弹出第一个元素（当前，也就是首部第一个)



10.`static constexper int` 和 `int` 的区别在于前者是一个编译时常量表达式，而后者只是一个普通的整数变量。`static constexper int` 在编译时就会被求值，而且具有**静态存储期**和**常量表达式属性**，因此在运行时具有更高的效率和安全性。相比之下，普通的 `int` 变量在运行时才被赋值，并且可以被修改。
