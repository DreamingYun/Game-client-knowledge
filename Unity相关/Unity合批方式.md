DrawCall  绘制调用

Draw call 绘制调用 通常指的是在计算机图形编程中，用于**触发图形硬件绘制图形的函数或命令**。当你在图形应用程序中绘制图形时，通常会使用图形API来执行这些绘图操作。**每次调用**图形API 的绘图函数时，都会**生成**一个draw call。

在图形渲染中，**draw call 会触发图形管线的执行**，包括顶点着色器、片段着色器等阶段，最终生成屏幕上的图像。绘制调用的性能对于图形应用程序和游戏非常重要，因为它们的效率直接影响到**图形的渲染速度**。



合批

合批就可以**广义**的理解为**减少渲染状态的设置**、**减少几何数据的收集绑定**、**减少DrawCall的调用**。Unity里的静态合批和动态合批**都有**一个前提条件那就是**网格使用的材质相同**。那么在大的复杂的场景里，其实是有很多使用了相同材质的物体的，这个时候如果使用合批那么性能肯定比仍然一个一个渲染要好的多。所以，在大的复杂的场景里如果有**很多物体使用了相同的材质**，那么这个时候不使用合批去渲染这些物体，就会造成性能浪费，所以要使用合批。

Unity中的静态合批static Batching

Unity的静态合批不会降低DrawCall调用

场景中选中需要静态合批的物体，在该物体的Inspector窗口中将右上角的**Static勾选上**。

条件

正如上面所说的 1、使用相同的**材质球**    2、**标明为Static**的静态物体

适用范围

像生活中的静态物体一样，建筑，树木等，因为计算合并后的数据在场景内就是固定的不会再变动

过程

① 游戏软件运行前，将场景内这些使用同一材质勾选static**物体的顶点、索引数据**提取出来**计算**，直接**变换**到世界空间下然后**再存入**一个大的顶点和索引缓冲中，并**记录**每个物体的**起始索引**

② 游戏运行后渲染场景时，**一次性提交整个合并后的顶点数据**，然后设置**一次**渲染状态，Unity的场景管理系统会判断每个物体的可见性，然后**分别调用DrawCall绘制每一个模型**

综上所述，静态合批在游戏软件**运行前就计算出一些数据直接存放**，然后运行时直接加载，预先计算数据这个过程Unity什么时候完成的呢？就是在**导出**安装包的时候，**计算出场景内静态合批物体的数据存放在了.scene文件里**，所以，有静态合批的时候安装包会比较大一些。需要注意的是在编辑器下就算你勾选了静态合批，在FrameDebug里看到了静态合批，其实也不是真正的静态合批，文件夹里的.scene文件也不会变大，而且FrameDebug里还会看到DrawCall减少(其实没减少)，因为这都是在打包的时候进行的，**打包后才会有效果**。

缺点

包体增大；将场景加载后，由于场景内有静态合批数据，会使内存变大。

总结：静态合批实际上是用**内存空间**来降低渲染的性能消耗(**减少设置渲染状态和提交几何数据**)





Unity中的动态合批Dynamic batching

如果物体**不是静态**不动的，**但是这些物体**仍然使用了同一材质球，那么这时候就可以使用动态合批

在自定义管线的工程下，会有渲染管线资源，Edit > Project Settings > Player->Other Settings->enable Dynamic Batching即打开动态合批，需要注意的是，在Unity的自定义管线项目里当物体可以同时进行多种合批的时候，合批的优先使用顺序**SRPBatcher>静态合批>GpuInstance>动态合批**

条件

1、使用相同的材质球 2、在视野范围内的物体

适用范围

**移动的**，没有进行前几种合批的物体

过程

①既然不能预先计算，那么可以**在运行**时，在**cpu里直接把可以合批物体的顶点等数据变换**到世界空间下

②渲染时，提交**合并后**的顶点数据，设置一次渲染状态，**调用一次DrawCall绘制多个模型**(不同于静态合批的多次调用DrawCall,因为可以进行动态合批的物体**已经判断过可见性**)

很明显，从过程中就可以看出，动态合批是**利用CPU的计算性能**消耗来换取渲染状态设置，几何处理和绘制调用的消耗

缺点

消耗CPU的计算性能，当计算消耗大于设置渲染状态等消耗时**得不偿失**。

总结：动态合批其实就是用消耗CPU的计算性能消耗来换取绘制性能，在现代图形API里绘制调用的消耗已经减小了，当cpu的计算消耗小于绘制调用消耗时动态合批才有效果。



GPUInstance

GPU实例化是一种通过利用图形处理单元（GPU）的特性，以更有效的方式**渲染大量相似的物体**的技术。这通常用于大规模的同类物体，如花、草等，它们在视觉上相似但可能具有不同的位置、旋转、缩放等差异。

条件

①使用相同材质②使用相同的**mesh**（网格）

适用范围

大规模的同mesh同材质小物件，需要表现不同的**位置、旋转、缩放**等差异，如渲染大量花、草等

过程

判断视野内满足条件的物体，抽取一个对象作为实例，将实例的顶点数据送往GPU，然后设置**着色器和着色器数据**(差异数据存入uniform数组中(**uniform 变量通常用于存储常量数据**，如光照参数、视图矩阵、投影矩阵等。它们的值在每个渲染批次中保持不变，因此在顶点着色器和片段着色器中都可以使用相同的常量数据))，最后调用绘制函数，那么顶点着色器就会循环渲染每个实例，并且每次都会用**实例ID去索引差异数组**来**渲染**出每一个实例。

限制

在某些图形API（如OpenGL）中**，GPU实例化可能受制于uniform变量的限制**。Uniform变量存储在GPU的**常量缓冲区**中，而显存是有限资源。因此，对于着色器的uniform变量有一定的限制。

总结：GPU实例化通过底层API的绘制调用和uniform数组，允许顶点着色器**多次执行并传递实例ID以索引存放了差异数据**的数组。相比于其他合批技术，GPU实例化不需要浪费内存，运算开销也相对较低，但在某些情况下可能受制于uniform变量的数量。







SRPBatcher

SRP Batcher是随着Unity的可定制渲染管线（**Scriptable Render Pipeline，SRP**）的引入而诞生出来的一种drawcall优化手段。根据官方的描述，它能在渲染期间对CPU性能提升1.2倍到4倍，这个幅度因场景而异。SRPBatcher的核心思想是通过**优化uniform数据**的设置，减少渲染状态切换的次数，从而提高渲染性能。

条件

相同Shader变体： 网格所用材质的Shader变体需要相同。 启用SRPBatcher： 在**渲染管线中启用SRPBatcher**，并且**Shader代码**需要符合SRPBatcher的要求。

过程

渲染第一个物体时：

将这一批次中的所有物体的物体相关属性数据**存入**UnityPerDraw缓存区(uniform 缓存对象)。 将这一批次中使用的所有材质的材质数据**存入**UnityPerMaterial缓存区(uniform 缓存对象)。 渲染其他物体时：

如果物体和上一个物体使用的**材质相同**，只需绑定UnityPerDraw缓存区，并调用DrawCall进行渲染。 如果物体和上一个物体使用的**材质不同**，需要额外绑定UnityPerMaterial缓存区，然后直接调用DrawCall进行渲染。

优势

一次性填充： 在批次开始渲染时，所有物体的**物体相关属性数据**和所用到的材质的**材质数据**都被一次性填充。 后续渲染只做绑定： 在批次开始后，**后续渲染只需进行缓存区的绑定（**在渲染过程中，GPU需要访问各种数据来执行顶点着色、片段着色等操作。这些数据通常存储在缓存区中。绑定操作告诉GPU在哪里可以找到这些数据，以便正确地执行渲染**）**，不再需要填充或更新常量缓存，从而减少性能开销。

总结： SRPBatcher通过对uniform数据的一次性填充和后续渲染的绑定操作，实现了对渲染性能的优化。它适用于需要大规模渲染相似物体的场景，**减少了渲染状态切换的次数**，提高了渲染效率。在使用SRPBatcher时，需要**确保Shader的编写符合SRPBatcher的要求**，且网格所用材质的Shader变体相同。





补充：

UI怎么优化drawcall

优化UI的DrawCall**可以通过以下几种方法实现：

合并UI元素。将多个相邻的UI元素合并成一个元素，例如使用Unity的Sprite Packer工具自动合并UI元素，可以减少DrawCall的数量。12

使用Mask组件。Mask组件可以限制UI元素的绘制区域，从而减少不必要的绘制。例如，在一个Panel中只有一部分需要显示时，可以添加一个Mask组件来限制显示区域，减少DrawCall。1

使用Static Batch和Dynamic Batch。Static Batch和Dynamic Batch分别是静态和动态合并技术，可以将多个静态或动态的UI元素合并成一个，以减少DrawCall的数量。

使用Atlas图集。将多个UI元素的纹理合并成一个Atlas图集，可以减少DrawCall的数量。在Unity中，可以使用SpriteAtlas来创建Atlas图集。

使用CanvasRenderer组件。通过使用CanvasRenderer组件来优化UI的渲染。

优化图集整理。将常用图片放在一个共有图集，独立界面的图片放在一个图集，一个UI最好控制在2~3个图集中。避免将不可能同时出现的东西放在同一个图集中。3

隐藏不必要的节点。在运行时隐藏不需要显示的节点，这样可以减少DrawCall的数量。4

统一Shader和纹理参数。确保合并的UI元素使用相同的Shader和纹理参数，以便进行合批处理。