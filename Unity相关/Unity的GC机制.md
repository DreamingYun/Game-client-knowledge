GC

GC（垃圾收集器）是一种**自动内存管理的机制**，用于检测和回收不再使用的内存资源，以便程序可以更有效地利用内存。GC **主要关注的是堆内存**，因为在堆内存中分配的对象通常没有明确的生命周期，所以由**垃圾收集器来负责追踪和处理**，但是如果垃圾过多将影响到GC的处理性能，从而降低整体的程序性能，在实际开发之中，对于垃圾的产生越少越好。

内存管理

Unity是自动内存管理

Unity中可以访问两个内存池**栈**内存和**堆**内存，栈用于短期存储的小数据，堆用于较长时间存储的较大的数据块。当创建变量的时候，Unity会从栈或堆中请求一个内存块，只要变量值作用域内（仍可被代码访问），分配给它的内存就会保留。当变量**不在作用域范围内**了，这块内存就不再需要了，被**创建它的那个内存池就被回收**。

只要变量的引用超出了**作用域**（在代码块外部引用变量，就超出了它的作用域），栈内存就会被**重新分配**（栈是一种后进先出的数据结构。当你进入一个新的代码块，该代码块的局部变量会被分配到栈上。当代码块执行完毕时，这些局部变量的**内存空间会被释放**，也就是栈内存被重新分配。），而堆的内存不同，堆内存不会重新分配即使变量的引用超出了作用域。而垃圾回收器会标识没有使用的堆内存，之后**定期清理堆内存**

**Unity会检测是否有足够的闲置内存单元用来存储数据**

如果有，则分配对应大小的内存单元 如果没有足够的存储单元，Unity会触发垃圾回收（GC）来**释放不再被使用的堆内存**。这步操作是一步缓慢的操作，如果GC后有足够大小的内存单元2，则进行内存分配。如果**GC后**还是没有足够的内存单元，**Unity会扩展堆内存的大小**，这步操作也会很缓慢，然后分配对应大小的内存单元给变量 GC是一个极其消耗性能的工作，**每次都需要遍历整个堆内存**，**堆内存上的变量或者引用越多**其运行的操作会更多，耗费的时间就越长

示例：

class Person

{

​    String name;     

​    int age;  

}

public class JavaDemo

{

​    public static void main(String args[])

​    {

​        Person per1 = new Person();   

​        Person per2 = new Person();

​        

​        per1.name = "liu";

​        per1.age = 11;

​        

​        per2.name = "yin";

​        per2.age = 12;

​        

​        per2 = per1;

​        per2.age = 100;

​    }

}

例如上面这段代码，当实例化per1和per2时会分配内存，当将per1的引用给per2时，per2分配的内存就变成了**内存垃圾**，这时候这段内存就会**被标记**为垃圾，在之后某个时候自动被释放掉





减少GC

手动强制调用**GC.Collect**

避免在Update、LateUpdate等每帧调用的函数中**频繁分配内存**

在运行时大量对象的创建和销毁依然会引起GC问题，用**对象池技术**可以让对象复用而不是重复的创建和销毁

值类型转换为引用类型的过程（装箱），**装箱**会产生GC

避免yield return 0，因为会产生GC，因为int类型的0被装箱，而使用yield return null替代则不会产生装箱操作。避免释放过多的堆内存，也需要在协程中**避免多次new**同一个WaitForSeconds对象