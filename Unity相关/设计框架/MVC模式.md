MVC设计模式认为**有三种不同的对象种类**:模型（Model），视图（View），控制器（Controller）。MVC模式定义了这些类型的对象在应用程序和它们在相互交互中所扮演的角色。在设计应用程序时，主要步骤是选择或者创建属于这三个组中的一个对象的自定义类。这三种类型的对象都被**抽象的边界分隔开**，并与跨边界的**其他类型的对象进行通信**。



优势

耦合性低

由于运用MVC的应用程序的三个部件是相互独立，改变其中一个不会影响其它两个，所以依据这种设计思想能构造良好的松耦合的构件。

重用性高

随着技术的不断进步，需要用越来越多的方式来访问应用程序。MVC模式允许使用各种不同样式的视图来访问同一个服务器端的代码，因为多个视图能共享一个模型

生命周期成本低

MVC使开发和维护用户接口的技术含量降低。

部署快

使用MVC模式使开发时间得到相当大的缩减，它使程序员集中精力于业务逻辑，界面程序员集中精力于表现形式上。

可维护性高

分离视图层和业务逻辑层也使得WEB应用更易于维护和修改。

有利软件工程化管理

由于不同的层各司其职，每一层不同的应用具有某些相同的特征，有利于通过工程化、工具化管理程序代码。控制器也提供了一个好处，就是可以使用控制器来联接不同的模型和视图去完成用户的需求，这样控制器可以为构造应用程序提供强有力的手段。给定一些可重用的模型和视图，控制器可以根据用户的需求选择模型进行处理，然后选择视图将处理结果显示给用户。





Model

**模型对象封装数据和基本行为**

模型对象表示特殊的知识和专长。它们**保存应用程序的数据**，并定义**处理该数据的逻辑**。一个设计良好的MVC应用程序将其**所有重要数据 在模型对象中封装**。一旦数据加载到应用程序中，任何属于应用程序持久状态的数据(无论是存储在文件或数据库中的持久状态)都应该位于在模型对象中。因为它们代表了与特定问题领域相关的知识和专长，所以它们往往是可重用的。

理想情况下，模型对象中没有用于与显示和编辑的用户界面（view）的明显连接。在实践中，这种分离并不总是有效的，在这个地方有一些灵活性，但是一般来说，模型对象不应该涉及接口和表示问题。



View

**视图对象向用户提供信息**

视图对象知道如何显示，允许用户**编辑应用程序模型中的数据**。视图不应该负责存储它正在显示的数据。当然，这并不意味着视图不会存储它所显示的数据。视图**可以缓存数据**，或者出于性能原因进行类似的操作。视图对象可以负责**只显示**模型对象的一部分，或整个模型对象，甚至是许多不同的模型对象。视图有很多不同的种类。

视图应该确保它正确显示模型。因此，它通常需要了解模型的更改。因为模型对象不应该被绑定到特定的视图对象上，所以它们需要一种通用的方法来表示模型对象已经更改。



Controller

**控制器对象将模型绑定到视图**

控制器对象充当应用程序的**视图对象**和它的**模型对象**之间的**中介**。控制器通常负责确保视图能够**访问**它们需要显示的模型对象，并充当视图了解模型更改的**通道**。控制器对象还可以**为**应用程序**执行设置**和绘制**视图任务**，并管理其他对象的生命周期。

当用户输入一个值或通过一个视图对象进行一个选择操作时，该值或选择将被传递给一个控制器对象。控制器对象会使用此应用程序特殊的方式理解这个操作,然后会传达给一个模型对象,让这个模型对象进行相应操作。或者说它可能会让模型对象对自己属性的改变进行反应。基于相同的用户输入，一些控制器对象可能还会告诉视图对象更改其外观或行为的某个方面。相反，当一个模型对象发生变化时——比如说，一个新的数据源被接受——**模型对象**通常会将这个变化传递给**一个控制器对象**，然后它会要求**一个或多个视图对象**来相应地更新自己。

控制器对象可以是可重用(**多个对象共享一个对象**)的，也可以是不可重用的，这取决于它们的群体类型。





补充**MVVM架构模式**

**MVVM（Model-View-ViewModel）**

是一种基于数据绑定的架构模式，用于设计和组织应用程序的代码结构。它将应用程序分为三个主要部分：Model（模型）、View（视图）和ViewModel（视图模型）。

Model（模型）：负责处理数据和业务逻辑。它可以是从网络获取的数据、数据库中的数据或其他数据源。Model层通常是独立于界面的，可以在多个界面之间共享。

View（视图）：负责展示数据和与用户进行交互。它可以是Activity、Fragment、View等。View层主要负责UI的展示和用户输入的响应。

ViewModel（视图模型）：连接View和Model，作为View和Model之间的桥梁。它负责从Model中获取数据，并将数据转换为View层可以直接使用的形式。ViewModel还负责监听Model的数据变化，并通知View进行更新。ViewModel通常是与View一一对应的，每个View都有一个对应的ViewModel。

**MVVM的特点和优势**

解耦合：MVVM通过将View和Model解耦合，使得它们可以独立开发和测试。ViewModel作为中间层，将数据从Model传递给View，避免了直接在View中处理业务逻辑的情况。

可维护性：MVVM的分层结构使得代码更易于维护。View只负责展示数据和用户交互，ViewModel负责处理业务逻辑和数据转换，Model负责数据的获取和存储。这种分离使得代码更加清晰和可读，也方便进行单元测试。

数据驱动UI：MVVM采用数据绑定的方式，将Model的数据与View进行绑定。当Model的数据发生变化时，ViewModel会自动更新View的显示，无需手动更新UI。这种方式可以减少手动更新UI的代码量，提高开发效率。

可测试性：由于MVVM的分层结构和数据驱动UI的特点，可以更容易地进行单元测试。ViewModel中的业务逻辑可以独立于View进行测试，而不需要依赖于Android系统或UI组件。



**Model（模型）：**

\- 职责：负责处理数据和业务逻辑。它可以是从网络获取的数据、数据库中的数据或其他数据源。Model层通常是独立于界面的，可以在多个界面之间共享。 - 作用：提供数据和处理数据的方法，封装业务逻辑

**View（视图）：**

\- 职责：负责展示数据和与用户进行交互。它可以是Activity、Fragment、View等。View层主要负责UI的展示和用户输入的响应。 - 作用：将ViewModel中的数据展示给用户，并将用户的输入传递给ViewModel。

**ViewModel（视图模型）：**

\- 职责：连接View和Model，作为View和Model之间的桥梁。它负责从Model中获取数据，并将数据转换为View层可以直接使用的形式。ViewModel还负责监听Model的数据变化，并通知View进行更新。ViewModel通常是与View一一对应的，每个View都有一个对应的ViewModel。 - 作用：处理View层的数据展示和用户交互，并与Model层进行交互。