线程

线程是一个执行上下文，包含诸多状态数据：每个线程都有自己的执行流、调用栈、错误码、信息掩码、私有数据。线程的入口函数就是线程执行的起点，线程从入口函数开始、一个指令接着一个指令执行，中间它可能会调用其他函数，那么它的控制流就转到了被调用的函数继续执行，被调用函数里还可以继续调用其他函数，这样便形成一个函数调用链。



多线程

一个进程内多个线程并发执行的情况就叫多线程，每个线程是一个独立的执行流，多线程是一种编程模型，它与处理器无关、跟设计有关。

需要多线程的原因包括：

并行计算：充分利用多核（Core），提升整体吞吐，加快执行速度后台任务处理：将后台线程和主线程分离，在特定场景它是不可或缺的，如：响应式用户界面、实时系统等。

实际上，为每个文件启动一个线程未必合适，因为如果有数万个小文件，那么启动数万个线程，每个线程运行很短暂的时间，大量时间将耗费在线程创建和销毁上。

可以使用如下的线程池进行改进，

开启一个线程池，线程数等于Core（核）数或二倍Core数（策略）每个工作线程尝试去文件列表（文件列表需要用锁保护起来）里取一个文件成功，统计这个文件的单词出现次数失败，该工作线程就退出待所有工作线程退出后，在主线程里合并结果这样的多线程程序能加快处理速度，前面数组求和可以采用相似的处理，如果程序运行在多CPU多Core的机器上，就能充分利用多CPU多Core硬件优势，多线程加速执行是多线程的一个显而易见的主要目的。



线程间通讯方式

共享内存：多个线程共享同一块内存区域，通过读写这块内存来实现通信。需要注意的是，在共享内存的情况下，需要确保对共享数据的访问是原子的，否则可能发生竞态条件。

互斥锁（Mutex）：通过互斥锁可以保证在同一时刻只有一个线程能够访问共享资源。一个线程在访问共享资源之前会尝试获取锁，如果获取不到就等待，直到锁被释放。

条件变量（Condition Variable）：条件变量用于线程之间的条件同步。一个线程可以在满足特定条件时等待条件变量，而另一个线程在满足条件时发出信号或广播通知其他线程。

信号量（Semaphore）：信号量是一个计数器，用于控制对共享资源的访问。线程在访问资源之前必须获取信号量，访问完后释放信号量。

管道（Pipe）： 管道是一种单向通信机制，可以用于父子进程或者通过线程间进行通信。一个线程写入管道，另一个线程从管道读取。

消息队列（Message Queue）：线程可以通过消息队列发送和接收消息。一个线程将消息放入队列，而另一个线程则从队列中取出消息。

套接字（Socket）：在网络编程中，套接字可以用于不同计算机上的线程间通信。套接字提供了一种通过网络进行通信的方式。



多线程同步

同一进程内的多个线程会共享数据，对共享数据的并发访问会出现竞争状况。

所以需要多线程同步：

去协调多个线程对共享数据的访问，避免出现数据不一致的情况协调各个事件的发生顺序，使多线程在某个点交汇并按预期步骤往前推进，比如某线程需要等另一个线程完成某项工作才能开展该线程的下一步工作要掌握多线程同步，需先理解为什么需要多线程同步、哪些情况需要同步。

多线程程序里，我们要保护的是数据而非代码，虽然Java等语言里有临界代码、sync方法，但最终要保护的还是代码访问的数据。



避免多个线程争抢一个资源

  1、串行化

如果有一个线程正在访问某共享（临界）资源，那么在它结束访问之前，其他线程不能执行访问同一资源的代码（访问临界资源的代码叫临界代码），其他线程想要访问同一资源，则它必须等待，直到那个线程访问完成，它才能获得访问的机会

对多线程访问共享资源施加此种约束就叫串行化



2. 原子操作和原子变量

如果操作满足原子性（是指一个操作是不可分割的，要么全部执行，要么全部不执行，没有中间状态），那么线程并发执行操作，就不会有问题。

Linux操作系统和C/C++编程语言都提供了整型原子变量，原子变量的自增、自减等操作都是原子的，操作是原子性的，意味着它是一个不可细分的操作整体，原子变量的用户观察它，只能看到未完成和已完成2种状态，看不到半完成状态。

​    2.1 C/C++ 原子操作

在C++11及其之后的标准中，引入了 <atomic> 头文件，提供了一系列的原子操作模板类。其中的 std::atomic<int> 可用于创建原子整型变量，而相应的原子操作函数可用于对这些变量进行操作。

\#include <atomic>

std::atomic<int> my_atomic_variable(0);

my_atomic_variable.fetch_add(1);  // 原子性地增加

这里的 fetch_add 是一个原子操作，确保在多线程环境中对 my_atomic_variable 进行增加操作时不会发生竞态条件。

这些原子操作通常利用硬件的原子指令或者通过操作系统提供的原子操作接口来实现，以确保在多线程或多进程并发访问时的正确性。这些原子操作通常是底层的、硬件支持的操作，以确保在执行过程中没有其他线程或进程能够干扰。



​     3.锁

线程中锁的机制用于控制多个线程对共享资源的访问，以避免数据竞争和不一致性。常见的锁包括互斥锁（Mutex Lock）和信号量（Semaphore）。锁的基本原理是当一个线程获取到锁时（称为上锁），其他线程就无法访问被保护的资源，直到释放锁为止（称为解锁）。



1. 互斥锁（Mutex Lock）：一次只允许一个线程访问被保护资源，其他线程必须等待当前线程释放锁才能继续执行。



2. 信号量（Semaphore）：允许多个线程同时访问被保护资源，但需要控制同时访问的线程数量。信号量维护一个计数器，线程尝试获取锁时，如果计数器大于零则可以获取锁并将计数器减一，否则需要等待其他线程释放锁。



3. 读写锁（Read-Write Lock）：允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这种锁适用于读操作频繁、写操作较少的场景，可以提高并发性能。







锁的正确使用可以保证线程安全，避免数据竞争和资源不一致性问题，但过度使用锁可能导致性能下降和死锁等问题，因此需要根据实际情况合理选择和设计锁机制。