openGL是一个规范，例如NVIDIA驱动程序，包含了OpenGL的实现，也就是独属于它的实现。OpenGL函数是在开发者的显卡驱动中被实现的

优点是跨平台

着色器就是在GPU上运行的程序，其允许开发者在GPU上编写代码

具体下载哪个GLFW取决于你需要编译的平台

dll动态链接，lib静态链接（主要使用）

包含目录的导入--C/C++下的附加包含目录，以$(SolutionDir)为基础（通常为项目文件夹），加上相对于其的路径-->例：$(SolutionDir)Dependencies\GLFW\include

库的导入--链接器下的常规-附加库目录-重复以~基础~的操作，例：

$(SolutionDir)Dependencies\GLFW\lib-vc2015

然后直接在链接器下的输入-附加依赖项，直接加入静态库

x86是32位的处理器架构

[GLEW: The OpenGL Extension Wrangler Library (sourceforge.net)](https://glew.sourceforge.net/)---便于openGL开发的网站

观察glewinit的代码可发现，需要预处理定义下声明static以对应先前静态链接的方式

现代的OpenGL画图前，先创建顶点缓冲区，然后创建着色器，这是绘制的决定性因素

电脑上渲染的图形都是从三角形开始的

顶点缓冲区，就是一个内存缓冲区，一个内存字节数组。在显卡中，也就是VRAM显存中

过程：表示三角形的数据，放入显卡的显存中，然后发出DrawCall的指令（读取数据，将其绘制在屏幕上），CPU编写的代码可以告诉显卡怎么做，着色器就实现了这一点

着色器，就是运行在显卡上的程序，是一堆开发者可以编写的在显卡上运行的代码 

 

查询API的文档网站[docs.gl](https://docs.gl/)



而这些显存中的数据具体是顶点数据还是法线数据，需要去告知其内存结构

OpenGL的glVertexAttribPointer就可以实现

顶点包括很多数据（纹理坐标、法线），不仅仅是一个位置信息（顶点位置）

有些时候显卡会提供着色器，当开发者并没有提供着色器时



着色器主要关心顶点着色器和片段（像素）着色器

渲染管线（简易版）：CPU上写了一些数据，用显卡发送了数据，绑定了一些状态，然后调用Drawcall，进入着色器阶段，实际处理DrawCall指令并在屏幕上绘制一些东西

当真正发出Drawcall指令时，顶点着色器会被调用，然后片段着色器被调用

顶点着色器为开发者试图渲染的每个顶点调用，几个就调用几次。告诉OpenGL，你希望该顶点在屏幕空间的什么位置

片段着色器为每个需要光栅化的像素运行一次，就是对三角形中需要填充的每个像素调用一次，主要目的是决定该像素应该是什么颜色









